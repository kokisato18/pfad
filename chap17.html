<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/syntax.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script type="text/javascript" src="./js/jquery-latest.js"></script>
<script type="text/javascript" src="./js/jquery.tablesorter.min.js"></script>
<script type="text/javascript">
$(function() {
  $("#errata1").tablesorter({headers: {2: {sorter: false}}});
  $("#errata2").tablesorter({headers: {2: {sorter: false}}});
  $("#errata3").tablesorter({headers: {2: {sorter: false}}});
});
</script>
<title>17. Knuth-Morris-Prattアルゴリズム</title>
</head>
<body>
<div class="structure" id="header">
  <h1><a href="http://github.com/sampou-org/pfad/">PFAD：</a>17. Knuth-Morris-Prattアルゴリズム</h1>
</div>
<div class="structure" id="container">
  <div id="primary-contents">
    <div id="box">
      <h3 id="データの精緻化">データの精緻化</h3>
<h4 id="原文には明確に書いてないが-17.2-から-rep-.-op-x-op-rep-x-がいえる">原文には明確に書いてないが (17.2) から rep . op x = op’ (rep x) がいえる</h4>
<pre><code>   op' r = rep . op (abs r)
⇒ {- r に rep x を代入 -}
   op' (rep x) = rep . op (abs (rep x))
⇒ {- abs (rep x) = x だから -}
   op' (rep x) = rep . op x</code></pre>
<h4 id="op-の定義の-otherwise-op-rep-split-ws-tail-us-x-のところ">op’ の定義の otherwise = op’ (rep (split ws (tail us))) x のところ</h4>
<pre><code>rep(op の定義の otherwise のときの値)
=
rep (op (split ws (tail us)) x)
= {- 上記「rep . op x = op' (rep x) がいえる」の x を (split ws (tail us)) に y を x にあてはめれば -}
op' (rep (split ws (tail us))) x</code></pre>
<h4 id="grep-は以下のように定義できる">grep は以下のように定義できる</h4>
<pre><code>grep l (us,[])
=
Node (us, []) l (right us [])
=
Node (us,[]) l Null

grep l (us,v:vs)
=
Node (us,v:vs) l (right us (v:vs))
=
Node(us,v:vs) l (grep (left (us + [v]) vs) (us+[v],vs))
=
Node(us,v:vs) l (grep (if null us then root else op′ (left us vs) v) (us+[v],vs))
= {- if null us then root else op′ (left us vs) v = op′ l v を示せばよい。後で示す -}
Node(us,v:vs) l (grep (op′ l v) (us+[v],vs))

if null us then root else op′ (left us vs) v = op′ l v の証明

rep (us, vs) = grep (left us vs) (us, vs) なので
grep l (us,v:vs) として呼ばれるときは l = left us (v:vs) になっている。

us = [] のとき
if null us then root else op′ (left us vs) v = root

一方
op′ l v = op' (left [] (v:vs)) v = op' Null v = root
で一致。

us = u:us' のとき
if null us then root else op′ (left us vs) v
=
op' (left (u:us') vs) v

一方
op′ l v
=
op' (left (u:us') (v:vs)) v
= {- left (u:us') (v:vs) = left (u:us') vs を示せばよい。後から示す -}
op' (left (u:us') vs) v
で一致。

left (u:us') (v:vs) = left (u:us') vs の証明

left (u:us') (v:vs)
= {- left の定義。left の第2引数は影響しないことに注意 -}
rep (split ws us')
= {- left の定義。left の第2引数は影響しないことに注意 -}
left (u:us') vs</code></pre>
    </div>
  </div>
  <div id="secondary-contents">
    <div id="navigation">
      Last update: 2014-11-07 <br>
      <a href="index.html">HOME</a><br>
      <a href="errata.html">正誤表</a><br><br>
      解説などすこしずつ追加中
      <ol>
       <li><a href="chap01.html">最小自由数</a></li>
       <li><a href="chap02.html">上位者問題</a>
       <li><a href="chap03.html">鞍型探索の改良</a>
       <li><a href="chap04.html">選択問題</a>
       <li><a href="chap05.html">組和の整列</a>
       <li><a href="chap06.html">小町算</a>
       <li><a href="chap07.html">最小高さ木の構築</a>
       <li><a href="chap08.html">分解の貪欲アルゴリズム</a>
       <li><a href="chap09.html">セレブを探せ</a>
       <li><a href="chap10.html">重複の除去</a>
       <li><a href="chap11.html">最大非連続部分列和</a>
       <li><a href="chap12.html">接尾辞ランキング</a>
       <li><a href="chap13.html">Burrows-Wheeler変換</a>
       <li><a href="chap14.html">最後の接尾辞</a>
       <li><a href="chap15.html">すべての共通接頭辞</a>
       <li><a href="chap16.html">Boyer-Mooreアルゴリズム</a>
       <li><a href="chap17.html">Knuth-Morris-Prattアルゴリズム</a>
       <li><a href="chap18.html">プランニングで解く「ラッシュアワー」問題</a>
       <li><a href="chap19.html">簡単な数独ソルバー</a>
       <li><a href="chap20.html">「カウントダウン」問題</a>
       <li><a href="chap21.html">ハイロモルフィズムとネクサス</a>
       <li><a href="chap22.html">行列式の3つの計算法</a>
       <li><a href="chap23.html">凸包の内側</a>
       <li><a href="chap24.html">有理算術符号</a>
       <li><a href="chap25.html">整数算術符号</a>
       <li><a href="chap26.html">Schorr-Waiteアルゴリズム</a>
       <li><a href="chap27.html">順挿入</a>
       <li><a href="chap28.html">ループレス関数アルゴリズム</a>
       <li><a href="chap29.html">Johnson-Trotterアルゴリズム</a>
       <li><a href="chap30.html">だれでもわかる，クモの巣かけ</a>
      </ol>
    </div>
  </div>
</div>
<div class="structure" id="footer">
  &copy; 2014 Nobuo Yamashita all rights reserved.
</div>
</body>
</html>