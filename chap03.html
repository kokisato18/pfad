<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/syntax.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script type="text/javascript" src="./js/jquery-latest.js"></script>
<script type="text/javascript" src="./js/jquery.tablesorter.min.js"></script>
<script type="text/javascript">
$(function() {
  $("#errata1").tablesorter({headers: {2: {sorter: false}}});
  $("#errata2").tablesorter({headers: {2: {sorter: false}}});
  $("#errata3").tablesorter({headers: {2: {sorter: false}}});
});
</script>
<title>03. 鞍型探索の改良</title>
</head>
<body>
<div class="structure" id="header">
  <h1><a href="http://github.com/sampou-org/pfad/">PFAD：</a>03. 鞍型探索の改良</h1>
</div>
<div class="structure" id="container">
  <div id="primary-contents">
    <div id="box">
      <h4 id="こんどの-invert-は-最良の場合では-最悪の場合でolog-zステップしかかからないアルゴリズムになりますね">こんどの invert は … 最良の場合では … 最悪の場合でO(log z)ステップしかかからないアルゴリズムになりますね</h4>
<p>最悪の場合の話の中で最良の場合の計算を使っているような話のつながりになっている？？？ 検討中。</p>
<h4 id="この階段形状内の角部分に-z-が現れます">この階段形状内の角部分に z が現れます</h4>
<p>f(x,y) = z となる点 (x1,y1), (x2,y2), …(0 &lt;= x_i &lt; m, 0 &lt;= y_i &lt; n) を<br />スタート点 (0,n) からゴール点 (m,0) まで<br />(0,n) - (x1,n) - (x1,y1) - (x2,y1) - (x2,y2) …（右に行って下に行くの繰り返し）… (m,0)<br />と階段状につないでいくと f(x,y) = z になる点 (x,y) は下に行って右に行く曲がり方に現れる。<br />つまり単調増加関数 f の f(x,y) = z の解集合 (x,y) と階段の形状は一対一対応する。</p>
<h4 id="log-amn-ωm-log1nm-n-log1mn">log A(m,n) = Ω(m * log(1+n/m) + n * log(1+m/n))</h4>
<p>スターリングの公式</p>
<pre><code>n! 〜 √(2πn) * n^n/e^n</code></pre>
<p>を使う。</p>
<pre><code>A(m,n) = (m+n)!/(m! * n!) 
〜 √(2π(m+n)) * (m+n)^(m+n)/e^(m+n) / (√(2πm) m^m/e^m * √(2πn) n^n/e^n)
= √((m+n)/(2πmn)) * (m+n)^(m+n) / (m^m * n^n)
= √((1/m + 1/n)/(2π)) * (m+n)^m / m^m * (m+n)^n / n^n
= √((1/m + 1/n)/(2π)) * (1+n/m)^m * (1+m/n)^n
log を取ると
log A(m,n) 〜 1/2 * log((1/m + 1/n)/(2π)) + m * log(1+n/m) + n * log(1+m/n)
= Ω(m * log(1+n/m) + n * log(1+m/n))</code></pre>
    </div>
  </div>
  <div id="secondary-contents">
    <div id="navigation">
      Last update: 2014-11-19 <br>
      <a href="index.html">HOME</a><br>
      <a href="errata.html">正誤表</a>(2015-01-17)<br><br>
      解説などすこしずつ追加中
      <ol>
       <li><a href="chap01.html">最小自由数</a></li>
       <li><a href="chap02.html">上位者問題</a>
       <li><a href="chap03.html">鞍型探索の改良</a>
       <li><a href="chap04.html">選択問題</a>
       <li><a href="chap05.html">組和の整列</a>
       <li><a href="chap06.html">小町算</a>
       <li><a href="chap07.html">最小高さ木の構築</a>
       <li><a href="chap08.html">分解の貪欲アルゴリズム</a>
       <li><a href="chap09.html">セレブを探せ</a>
       <li><a href="chap10.html">重複の除去</a>
       <li><a href="chap11.html">最大非連続部分列和</a>
       <li><a href="chap12.html">接尾辞ランキング</a>
       <li><a href="chap13.html">Burrows-Wheeler変換</a>
       <li><a href="chap14.html">最後の接尾辞</a>
       <li><a href="chap15.html">すべての共通接頭辞</a>
       <li><a href="chap16.html">Boyer-Mooreアルゴリズム</a>
       <li><a href="chap17.html">Knuth-Morris-Prattアルゴリズム</a>
       <li><a href="chap18.html">プランニングで解く「ラッシュアワー」問題</a>
       <li><a href="chap19.html">簡単な数独ソルバー</a>
       <li><a href="chap20.html">「カウントダウン」問題</a>
       <li><a href="chap21.html">ハイロモルフィズムとネクサス</a>
       <li><a href="chap22.html">行列式の3つの計算法</a>
       <li><a href="chap23.html">凸包の内側</a>
       <li><a href="chap24.html">有理算術符号</a>
       <li><a href="chap25.html">整数算術符号</a>
       <li><a href="chap26.html">Schorr-Waiteアルゴリズム</a>
       <li><a href="chap27.html">順挿入</a>
       <li><a href="chap28.html">ループレス関数アルゴリズム</a>
       <li><a href="chap29.html">Johnson-Trotterアルゴリズム</a>
       <li><a href="chap30.html">だれでもわかる，クモの巣かけ</a>
      </ol>
    </div>
  </div>
</div>
<div class="structure" id="footer">
  &copy; 2014 Nobuo Yamashita all rights reserved.
</div>
</body>
</html>