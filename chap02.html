<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/syntax.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script type="text/javascript" src="./js/jquery-latest.js"></script>
<script type="text/javascript" src="./js/jquery.tablesorter.min.js"></script>
<script type="text/javascript">
$(function() {
  $("#errata").tablesorter({headers: {2: {sorter: false}}});
});
</script>
<title>02. 上位者問題</title>
</head>
<body>
<div class="structure" id="header">
  <h1><a href="http://github.com/sampou-org/pfad/">PFAD：</a>02. 上位者問題</h1>
</div>
<div class="structure" id="container">
  <div id="primary-contents">
    <div id="box">
      <h3 id="分割統治法">分割統治法</h3>
<h4 id="tableの定義より-d-tcount-x-tys">tableの定義より d ≤ tcount x tys′</h4>
<p>準備として二つの事実を示しておく。</p>
<p>まず一つめ、</p>
<pre><code>tcount x (table ys) = length (filter (x&lt;) ys)</code></pre>
<p>なぜなら</p>
<pre><code>tcount x (table ys)
= {- (2.1) -}
length (dropWhile ((x&gt;=) . fst) (table ys))
= {- table -}
length (dropWhile ((x&gt;=) . fst) (sort [(z, scount z zs) | z:zs &lt;- tails ys]))
= {- sort したものを (x&gt;=) で dropWhile すると残るのは (x&lt;) なものだけなので -}
length (filter ((x&lt;) . fst) (sort [(z, scount z zs) | z:zs &lt;- tails ys]))
= {- length . filter p . sort = length . filter p だから -}
length (filter ((x&lt;) . fst) [(z, scount z zs) | z:zs &lt;- tais ys])
= {- length . filter (p . f) = length . filter p . map f だから -}
length (filter ((x&lt;)) (map fst [(z, scount z zs) | z:zs &lt;- tails ys]))
=
length (filter ((x&lt;)) [z | z:zs &lt;- tails ys])
= {- [z | z:zs &lt;- tails ys] = ys だから -}
length (filter ((x&lt;)) ys)</code></pre>
<p>二つめ、</p>
<pre><code>table ys = (y,d): tys' とする。
ys から y を一つ削除したものを ys' とすると tys' = table ys'。
（ys に要素が y と等しいものが複数あるときはその中でも一番右にあるものを削除。）</code></pre>
<p>なぜなら</p>
<pre><code>[(z, scount z zs) | z:zs &lt;- tails ys] と [(z, scount z zs) | z:zs &lt;- tails ys'] を比べると
y は ys の中で最小なので y が削除されていても scount z zs に影響を与えない。
結局違いは (y,d) があるかないかだけの違いになる。したがって
sort [(z, scount z zs) | z:zs &lt;- tails ys] = (y,d): sort [(z, scount z zs) | z:zs &lt;- tails ys']
つまり
table ys = (y,d): table ys'</code></pre>
<p>準備ができたので本題に入る。</p>
<p>tys@((y,d): tys’ = table ys とする。 上で述べた準備の二つめから tys’ = table ys’ と書ける。ここで ys’ は ys から y を一つ削除したもの。</p>
<pre><code>d
= {- table の作られ方より -}
scount y zs （ここで y: zs ∈ tails ys）
= {- scount の定義 -}
length (filter (y&lt;) zs)
&lt;= {- zs は ys の部分列だから -}
length (filter (y&lt;) ys)
= {- ys と ys' の違いは一つの y だけなので -}
length (filter (y&lt;) ys')
= {- 上で述べた準備の一つめより -}
tcount y (table ys')
= {- tys' = table ys' -}
tcount y tys'
= {- ここでは x = y のケースで考えているから -}
tcount x tys'</code></pre>
<h4 id="よりtcount-x-tys-tcount-x-tys-である">(2.1) よりtcount x tys = tcount x tys′ である</h4>
<pre><code>tcount x tys
= {- (2.1) -}
length (dropWhile ((x &gt;=) . fst) tys)
= {- tys = (y,d): tys' -}
length (dropWhile ((x &gt;=) . fst) ((y,d): tys'))
= {- ここでは x = y のケースで考えているので x &gt;= fst (y,d) -}
length (dropWhile ((x &gt;=) . fst) tys')
= {- (2.1) -}
tcount x tys′</code></pre>
<h3 id="所見">所見</h3>
<h4 id="table-xsの提供する情報はxsの並べ換えのうち整列されているものを決定できるほどのものになるからである">table xsの提供する情報はxsの並べ換えのうち整列されているものを決定できるほどのものになるからである</h4>
<p>後で書く。</p>
    </div>
  </div>
  <div id="secondary-contents">
    <div id="navigation">
      Last update: 2014-11-14 <br>
      <a href="index.html">HOME</a><br>
      <a href="errata.html">正誤表</a>
      <ol>
       <li><a href="chap01.html">最小自由数</a></li>
       <li><a href="chap02.html">上位者問題</a>
       <li><a href="chap03.html">鞍型探索の改良</a>
       <li><a href="chap04.html">選択問題</a>
       <li><a href="chap05.html">組和の整列</a>
       <li><a href="chap06.html">小町算</a>
       <li><a href="chap07.html">最小高さ木の構築</a>
       <li><a href="chap08.html">分解の貪欲アルゴリズム</a>
       <li><a href="chap09.html">セレブを探せ</a>
       <li><a href="chap10.html">重複の除去</a>
       <li><a href="chap11.html">最大非連続部分列和</a>
       <li><a href="chap12.html">接尾辞ランキング</a>
       <li><a href="chap13.html">Burrows-Wheeler変換</a>
       <li><a href="chap14.html">最後の接尾辞</a>
       <li><a href="chap15.html">すべての共通接頭辞</a>
       <li><a href="chap16.html">Boyer-Mooreアルゴリズム</a>
       <li><a href="chap17.html">Knuth-Morris-Prattアルゴリズム</a>
       <li><a href="chap18.html">プランニングで解く「ラッシュアワー」問題</a>
       <li><a href="chap19.html">簡単な数独ソルバー</a>
       <li><a href="chap20.html">「カウントダウン」問題</a>
       <li><a href="chap21.html">ハイロモルフィズムとネクサス</a>
       <li><a href="chap22.html">行列式の3つの計算法</a>
       <li><a href="chap23.html">凸包の内側</a>
       <li><a href="chap24.html">有理算術符号</a>
       <li><a href="chap25.html">整数算術符号</a>
       <li><a href="chap26.html">Schorr-Waiteアルゴリズム</a>
       <li><a href="chap27.html">順挿入</a>
       <li><a href="chap28.html">ループレス関数アルゴリズム</a>
       <li><a href="chap29.html">Johnson-Trotterアルゴリズム</a>
       <li><a href="chap30.html">だれでもわかる，クモの巣かけ</a>
      </ol>
    </div>
  </div>
</div>
<div class="structure" id="footer">
  &copy; 2014 Nobuo Yamashita all rights reserved.
</div>
</body>
</html>