<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="css/default.css">
<link rel="stylesheet" type="text/css" href="css/syntax.css">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script type="text/javascript" src="./js/jquery-latest.js"></script>
<script type="text/javascript" src="./js/jquery.tablesorter.min.js"></script>
<script type="text/javascript">
$(function() {
  $("#errata1").tablesorter({headers: {2: {sorter: false}}});
  $("#errata2").tablesorter({headers: {2: {sorter: false}}});
  $("#errata3").tablesorter({headers: {2: {sorter: false}}});
});
</script>
<title>19. 簡単な数独ソルバー</title>
</head>
<body>
<div class="structure" id="header">
  <h1><a href="http://github.com/sampou-org/pfad/">PFAD：</a>19. 簡単な数独ソルバー</h1>
</div>
<div class="structure" id="container">
  <div id="primary-contents">
    <div id="box">
      <h2 id="cols-の対合性">cols の対合性</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">cols ::</span> [[a]] <span class="ot">-&gt;</span> [[a]]
cols [xs]     <span class="fu">=</span> map (<span class="fu">:</span>[]) xs
cols (xs<span class="fu">:</span>xss) <span class="fu">=</span> zipWith (<span class="fu">:</span>) xs (cols xss)</code></pre></div>
<p><code>cols (cols xss) = xss</code> <code>xss</code>上の帰納法</p>
<p><code>[[x]]</code>の場合</p>
<pre><code>  cols (cols [[x]])
=   { cols の定義 }
  cols (map (:[]) [x])
=   { map の定義 }
  cols ([x] : map (:[]) [])
=   { map の定義 }
  cols ([x] : [])
=   { リストの記法 }
  cols [[x]]
=   { 同様の運算を繰り返す }
  [[x]]</code></pre>
<p><code>[x:xs]</code>の場合</p>
<pre><code>  cols (cols [x:xs])
=   { colsの定義 }
  cols (map (:[]) (x:xs))
=   { map の定義 }
  cols ([x] : map (:[]) xs))
=   { cols の定義 }
  cols ([x] : cols [xs])
=   { cols の定義 }
  zipWith (:) [x] (cols (cols [xs]))
=   { 帰納法の仮定 }
  zipWith (:) [x] [xs]
=   { zipWith の定義 }
  [x:xs]</code></pre>
<p><code>xs:xss</code>の場合</p>
<pre><code>  cols (cols (xs:xss))
=   { cols の定義 }
  cols (zipWith (:) xs (cols xss))
=   { zipWith (:) xs = zipWith (++) (map (:[]) xs) であるから }
  cols (zipWith (++) (map (:[]) xs) (cols xss))
=   { cols の定義 }
  cols (zipWith (++) (cols [xs]) (cols xss))
=   { zipWith (++) = (⊕) とする }
  cols (cols [xs] ⊕ cols xss)
=   { 補題: cols (xss ⊕ yss) = cols xss ++ cols yss }
  cols (cols [xs]) ++ cols (cols xss)
=   { 帰納法の仮定 }
  [xs] ++ xss
=   { (++) の定義 }
  xs:xss</code></pre>
<h2 id="補題">補題</h2>
<pre><code>cols (xss ⊕ yss) = cols xss ++ cols yss
  where
    (⊕) = zipWith (++)</code></pre>
<p>この補題には以下の付帯条件がある．</p>
<pre><code>  (1) 0 &lt; length xss = length yss
  (2) 0 &lt; lenght (head xss)
  (3) 0 &lt; length (head yss)
  (4) all (length (head xss) ==) xss
  (5) all (length (head yss) ==) xss</code></pre>
<p>証明は<code>xss</code>上の帰納法による</p>
<p><code>[xs]</code>の場合 付帯条件(1)より<code>yss = [ys]</code></p>
<pre><code>  cols ([xs] ⊕ [ys])
=   { ⊕ の定義 }
  cols (zipWith (++) [xs] [ys])
=   { zipWith の定義 }
  cols ((xs++ys) : zipWith (++) [] [])
=   { zipWith の定義 }
  cols ((xs++ys):[])
=   { リストの記法 }
  cols [xs++ys]
=   { cols 定義 }
  map (:[]) (xs++ys)
=   { map-++ 則 }
  map (:[]) xs ++ map (:[]) ys
=   { cols の定義 }
  cols xs ++ cols ys</code></pre>
<p><code>(xs:xss)</code>の場合 付帯条件(1)より<code>yss</code>は<code>ys : yss</code>と表せる</p>
<pre><code>  cols ((xs:xss) ⊕ (ys:yss))
=   { ⊕ の定義 }
  cols (zipWith (++) (xs:xss) (ys:yss))
=   { zipWith の定義 }
  cols ((xs++ys) : zipWith (++) xss yss)
=   { ⊕ の定義 }
  cols ((xs++ys) : (xss ⊕ yss))
=   { cols の定義 }
  zipWith (:) (xs++ys) (cols (xss ⊕ yss))
=   { 帰納法の仮定より }
  zipWith (:) (xs++ys) (cols xss ++ cols yss)
=   { 付帯条件 (4) より length xs = length (cols xss) なので }
  zipWith (:) xs (cols xss) ++ zipWith (:) ys (cols yys)
=   { cols の定義より }
  cols (xs:xss) ++ cols (ys:yss)</code></pre>
    </div>
  </div>
  <div id="secondary-contents">
    <div id="navigation">
      Last update: 2017-01-17 <br>
      <a href="index.html">HOME</a><br>
      <a href="errata.html">正誤表</a>(2015-01-17)<br><br>
      解説などすこしずつ追加中
      <ol>
       <li><a href="chap01.html">最小自由数</a></li>
       <li><a href="chap02.html">上位者問題</a>
       <li><a href="chap03.html">鞍型探索の改良</a>
       <li><a href="chap04.html">選択問題</a>
       <li><a href="chap05.html">組和の整列</a>
       <li><a href="chap06.html">小町算</a>
       <li><a href="chap07.html">最小高さ木の構築</a>
       <li><a href="chap08.html">分解の貪欲アルゴリズム</a>
       <li><a href="chap09.html">セレブを探せ</a>
       <li><a href="chap10.html">重複の除去</a>
       <li><a href="chap11.html">最大非連続部分列和</a>
       <li><a href="chap12.html">接尾辞ランキング</a>
       <li><a href="chap13.html">Burrows-Wheeler変換</a>
       <li><a href="chap14.html">最後の接尾辞</a>
       <li><a href="chap15.html">すべての共通接頭辞</a>
       <li><a href="chap16.html">Boyer-Mooreアルゴリズム</a>
       <li><a href="chap17.html">Knuth-Morris-Prattアルゴリズム</a>
       <li><a href="chap18.html">プランニングで解く「ラッシュアワー」問題</a>
       <li><a href="chap19.html">簡単な数独ソルバー</a>
       <li><a href="chap20.html">「カウントダウン」問題</a>
       <li><a href="chap21.html">ハイロモルフィズムとネクサス</a>
       <li><a href="chap22.html">行列式の3つの計算法</a>
       <li><a href="chap23.html">凸包の内側</a>
       <li><a href="chap24.html">有理算術符号</a>
       <li><a href="chap25.html">整数算術符号</a>
       <li><a href="chap26.html">Schorr-Waiteアルゴリズム</a>
       <li><a href="chap27.html">順挿入</a>
       <li><a href="chap28.html">ループレス関数アルゴリズム</a>
       <li><a href="chap29.html">Johnson-Trotterアルゴリズム</a>
       <li><a href="chap30.html">だれでもわかる，クモの巣かけ</a>
      </ol>
    </div>
  </div>
</div>
<div class="structure" id="footer">
  &copy; 2014-2017 Nobuo Yamashita all rights reserved.
</div>
</body>
</html>
